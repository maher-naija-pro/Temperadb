name: Docker Build and Test

on:
  push:
    tags:
      - 'v*'
    branches: [ main, master, test ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: timeseriesdb
  PORT: 8080

permissions:
  contents: read
  packages: write

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      run: |
        # Extract version from git
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
        fi
        
        # Extract commit hash
        COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        
        # Extract build time
        BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
        
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_OUTPUT
        echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_OUTPUT
        
        echo "üìã Build metadata:"
        echo "  Version: $VERSION"
        echo "  Commit: $COMMIT_HASH"
        echo "  Build time: $BUILD_TIME"

    - name: Build Docker image
      id: build
      run: |
        echo "üî® Building Docker image..."
        echo "Image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
        
        # Build the image
        docker build \
          --build-arg VERSION=${{ steps.meta.outputs.VERSION }} \
          --build-arg GOOS=linux \
          --build-arg GOARCH=amd64 \
          -t ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} \
          -t ${{ env.IMAGE_NAME }}:latest \
          .
        
        echo "‚úÖ Docker image built successfully"
        
        # Show image details
        echo "üìã Image details:"
        docker images | grep ${{ env.IMAGE_NAME }}
        
        # Show image layers
        echo "üîç Image layers:"
        docker history ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} | head -10

    - name: Test Docker image
      id: test
      run: |
        echo "üß™ Starting comprehensive Docker image testing..."
        echo "Image: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
        
        # Check required tools
        echo "üîß Checking required tools..."
        if ! command -v jq >/dev/null 2>&1; then
          echo "‚ùå jq is not available, installing..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
        
        if ! command -v curl >/dev/null 2>&1; then
          echo "‚ùå curl is not available, installing..."
          sudo apt-get update && sudo apt-get install -y curl
        fi
        
        # Generate unique container name
        CONTAINER_NAME="test-${{ env.IMAGE_NAME }}-$(date +%s)"
        echo "Container name: $CONTAINER_NAME"
        
        # Start container
        echo "üöÄ Starting test container..."
        CONTAINER_ID=$(docker run -d \
          --name "$CONTAINER_NAME" \
          -p ${{ env.PORT }}:${{ env.PORT }} \
          -e DEBUG=true \
          -e LOG_LEVEL=debug \
          ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }})
        
        echo "Container ID: $CONTAINER_ID"
        
        # Wait for container to start and verify it's running
        echo "‚è≥ Waiting for container to start..."
        sleep 5
        
        # More robust container verification
        echo "üîç Verifying container status..."
        if ! docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}" | grep -q "$CONTAINER_NAME"; then
          echo "‚ùå Container not found in running containers list"
          echo "üîç Container logs:"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Container inspect:"
          docker inspect "$CONTAINER_NAME" | jq '.[0].State' || echo "Could not inspect container"
          exit 1
        fi
        
        # Additional verification using container inspect
        CONTAINER_STATUS=$(docker inspect "$CONTAINER_NAME" --format='{{.State.Status}}' 2>/dev/null)
        if [ "$CONTAINER_STATUS" != "running" ]; then
          echo "‚ùå Container is not in running state. Current status: $CONTAINER_STATUS"
          echo "üîç Container logs:"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Container inspect:"
          docker inspect "$CONTAINER_NAME" | jq '.[0].State' || echo "Could not inspect container"
          exit 1
        fi
        
        echo "‚úÖ Container is running"
        
        # Show container status for debugging
        echo "üìã Container status:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep "$CONTAINER_NAME" || echo "Container not found in ps output"
        
        # Wait for health check to pass
        echo "üè• Waiting for health check to pass..."
        HEALTH_ATTEMPTS=0
        MAX_HEALTH_ATTEMPTS=30
        
        # Also check if the port is actually listening
        echo "üîå Checking if port ${{ env.PORT }} is listening..."
        PORT_ATTEMPTS=0
        MAX_PORT_ATTEMPTS=15
        while [ $PORT_ATTEMPTS -lt $MAX_PORT_ATTEMPTS ]; do
          if netstat -tuln 2>/dev/null | grep -q ":${{ env.PORT }} "; then
            echo "‚úÖ Port ${{ env.PORT }} is listening"
            break
          elif ss -tuln 2>/dev/null | grep -q ":${{ env.PORT }} "; then
            echo "‚úÖ Port ${{ env.PORT }} is listening (ss)"
            break
          else
            echo "‚è≥ Waiting for port ${{ env.PORT }} to listen... (attempt $((PORT_ATTEMPTS + 1))/$MAX_PORT_ATTEMPTS)"
            sleep 2
            PORT_ATTEMPTS=$((PORT_ATTEMPTS + 1))
          fi
        done
        
        if [ $PORT_ATTEMPTS -eq $MAX_PORT_ATTEMPTS ]; then
          echo "‚ö†Ô∏è  Port ${{ env.PORT }} not listening after $MAX_PORT_ATTEMPTS attempts, proceeding anyway"
        fi
        
        # Test network connectivity from host
        echo "üåê Testing network connectivity from host..."
        if ping -c 1 localhost >/dev/null 2>&1; then
          echo "‚úÖ Localhost ping successful"
        else
          echo "‚ö†Ô∏è  Localhost ping failed, but proceeding with tests"
        fi
        
  
    - name: Push Docker image
      if: github.event_name != 'pull_request'
      run: |
        echo "üì§ Pushing Docker image to registry..."
        
        # Tag for registry
        docker tag ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} \
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
        docker tag ${{ env.IMAGE_NAME }}:latest \
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        
        # Push images
        docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
        docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        
        echo "‚úÖ Images pushed successfully"

