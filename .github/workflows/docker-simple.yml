name: Docker Build and Test

on:
  push:
    tags:
      - 'v*'
    branches: [ main, master, test ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: timeseriesdb
  PORT: 8080

permissions:
  contents: read
  packages: write

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      run: |
        # Extract version from git
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
        else
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
        fi
        
        # Extract commit hash
        COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        
        # Extract build time
        BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
        
        echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
        echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_OUTPUT
        echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_OUTPUT
        
        echo "üìã Build metadata:"
        echo "  Version: $VERSION"
        echo "  Commit: $COMMIT_HASH"
        echo "  Build time: $BUILD_TIME"

    - name: Build Docker image
      id: build
      run: |
        echo "üî® Building Docker image..."
        echo "Image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
        
        # Build the image
        docker build \
          --build-arg VERSION=${{ steps.meta.outputs.VERSION }} \
          --build-arg GOOS=linux \
          --build-arg GOARCH=amd64 \
          -t ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} \
          -t ${{ env.IMAGE_NAME }}:latest \
          .
        
        echo "‚úÖ Docker image built successfully"
        
        # Show image details
        echo "üìã Image details:"
        docker images | grep ${{ env.IMAGE_NAME }}
        
        # Show image layers
        echo "üîç Image layers:"
        docker history ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} | head -10

    - name: Test Docker image
      id: test
      run: |
        echo "üß™ Starting comprehensive Docker image testing..."
        echo "Image: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
        
        # Check required tools
        echo "üîß Checking required tools..."
        if ! command -v jq >/dev/null 2>&1; then
          echo "‚ùå jq is not available, installing..."
          sudo apt-get update && sudo apt-get install -y jq
        fi
        
        if ! command -v curl >/dev/null 2>&1; then
          echo "‚ùå curl is not available, installing..."
          sudo apt-get update && sudo apt-get install -y curl
        fi
        
        # Generate unique container name
        CONTAINER_NAME="test-${{ env.IMAGE_NAME }}-$(date +%s)"
        echo "Container name: $CONTAINER_NAME"
        
        # Start container
        echo "üöÄ Starting test container..."
        CONTAINER_ID=$(docker run -d \
          --name "$CONTAINER_NAME" \
          -p ${{ env.PORT }}:${{ env.PORT }} \
          -e DEBUG=true \
          -e LOG_LEVEL=debug \
          ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }})
        
        echo "Container ID: $CONTAINER_ID"
        
        # Wait for container to start and verify it's running
        echo "‚è≥ Waiting for container to start..."
        sleep 5
        
        # More robust container verification
        echo "üîç Verifying container status..."
        if ! docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}" | grep -q "$CONTAINER_NAME"; then
          echo "‚ùå Container not found in running containers list"
          echo "üîç Container logs:"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Container inspect:"
          docker inspect "$CONTAINER_NAME" | jq '.[0].State' || echo "Could not inspect container"
          exit 1
        fi
        
        # Additional verification using container inspect
        CONTAINER_STATUS=$(docker inspect "$CONTAINER_NAME" --format='{{.State.Status}}' 2>/dev/null)
        if [ "$CONTAINER_STATUS" != "running" ]; then
          echo "‚ùå Container is not in running state. Current status: $CONTAINER_STATUS"
          echo "üîç Container logs:"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Container inspect:"
          docker inspect "$CONTAINER_NAME" | jq '.[0].State' || echo "Could not inspect container"
          exit 1
        fi
        
        echo "‚úÖ Container is running"
        
        # Show container status for debugging
        echo "üìã Container status:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep "$CONTAINER_NAME" || echo "Container not found in ps output"
        
        # Wait for health check to pass
        echo "üè• Waiting for health check to pass..."
        HEALTH_ATTEMPTS=0
        MAX_HEALTH_ATTEMPTS=30
        
        # Also check if the port is actually listening
        echo "üîå Checking if port ${{ env.PORT }} is listening..."
        PORT_ATTEMPTS=0
        MAX_PORT_ATTEMPTS=15
        while [ $PORT_ATTEMPTS -lt $MAX_PORT_ATTEMPTS ]; do
          if netstat -tuln 2>/dev/null | grep -q ":${{ env.PORT }} "; then
            echo "‚úÖ Port ${{ env.PORT }} is listening"
            break
          elif ss -tuln 2>/dev/null | grep -q ":${{ env.PORT }} "; then
            echo "‚úÖ Port ${{ env.PORT }} is listening (ss)"
            break
          else
            echo "‚è≥ Waiting for port ${{ env.PORT }} to listen... (attempt $((PORT_ATTEMPTS + 1))/$MAX_PORT_ATTEMPTS)"
            sleep 2
            PORT_ATTEMPTS=$((PORT_ATTEMPTS + 1))
          fi
        done
        
        if [ $PORT_ATTEMPTS -eq $MAX_PORT_ATTEMPTS ]; then
          echo "‚ö†Ô∏è  Port ${{ env.PORT }} not listening after $MAX_PORT_ATTEMPTS attempts, proceeding anyway"
        fi
        
        # Test network connectivity from host
        echo "üåê Testing network connectivity from host..."
        if ping -c 1 localhost >/dev/null 2>&1; then
          echo "‚úÖ Localhost ping successful"
        else
          echo "‚ö†Ô∏è  Localhost ping failed, but proceeding with tests"
        fi
        
        while [ $HEALTH_ATTEMPTS -lt $MAX_HEALTH_ATTEMPTS ]; do
          HEALTH_STATUS=$(docker inspect "$CONTAINER_NAME" --format='{{.State.Health.Status}}' 2>/dev/null)
          if [ "$HEALTH_STATUS" = "healthy" ]; then
            echo "‚úÖ Health check passed"
            break
          elif [ "$HEALTH_STATUS" = "unhealthy" ]; then
            echo "‚ùå Health check failed"
            docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
            exit 1
          else
            echo "‚è≥ Waiting for health check... (attempt $((HEALTH_ATTEMPTS + 1))/$MAX_HEALTH_ATTEMPTS)"
            sleep 2
            HEALTH_ATTEMPTS=$((HEALTH_ATTEMPTS + 1))
          fi
        done
        
        if [ $HEALTH_ATTEMPTS -eq $MAX_HEALTH_ATTEMPTS ]; then
          echo "‚ö†Ô∏è  Health check timeout after $MAX_HEALTH_ATTEMPTS attempts, proceeding with basic connectivity test"
          echo "üîç Container logs (last 20 lines):"
          docker logs --tail 20 "$CONTAINER_NAME" || echo "Could not retrieve logs"
        fi
        
        # Wait for application to initialize
        echo "‚è≥ Waiting for application to initialize..."
        INIT_ATTEMPTS=0
        MAX_INIT_ATTEMPTS=20
        CONNECTIVITY_ESTABLISHED=false
        
        while [ $INIT_ATTEMPTS -lt $MAX_INIT_ATTEMPTS ] && [ "$CONNECTIVITY_ESTABLISHED" = false ]; do
          INIT_ATTEMPTS=$((INIT_ATTEMPTS + 1))
          echo "Initialization check $INIT_ATTEMPTS/$MAX_INIT_ATTEMPTS..."
          
          # Check if container is still running using container name
          if ! docker ps --format "table {{.Names}}" | grep -q "$CONTAINER_NAME"; then
            echo "‚ùå Container stopped during initialization"
            echo "üîç Container logs (last 20 lines):"
            docker logs --tail 20 "$CONTAINER_NAME" || echo "Could not retrieve logs"
            exit 1
          fi
          
                          # Test basic connectivity with timeout (fallback to regular curl if timeout not available)
        if command -v timeout >/dev/null 2>&1; then
          if timeout 5 curl -f -s http://localhost:${{ env.PORT }}/ >/dev/null 2>&1; then
            echo "‚úÖ Basic connectivity established"
            CONNECTIVITY_ESTABLISHED=true
            break
          fi
        else
          if curl -f -s --max-time 5 http://localhost:${{ env.PORT }}/ >/dev/null 2>&1; then
            echo "‚úÖ Basic connectivity established"
            CONNECTIVITY_ESTABLISHED=true
            break
          fi
        fi
          else
            echo "‚è≥ Waiting for connectivity... (attempt $INIT_ATTEMPTS/$MAX_INIT_ATTEMPTS)"
            sleep 3
          fi
        done
        
        if [ "$CONNECTIVITY_ESTABLISHED" = false ]; then
          echo "‚ùå Failed to establish connectivity after $MAX_INIT_ATTEMPTS attempts"
          echo "üîç Container logs (last 30 lines):"
          docker logs --tail 30 "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Container inspect:"
          docker inspect "$CONTAINER_NAME" | jq '.[0].State' || echo "Could not inspect container"
          exit 1
        fi
        
        # Final verification before endpoint tests
        echo "üîç Final verification before endpoint tests..."
        echo "üìã Container final status:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep "$CONTAINER_NAME" || echo "Container not found in ps output"
        
        # Test health endpoint
        echo "üè• Testing health endpoint..."
        
        # First, let's verify the container is accessible
        echo "üîç Verifying container accessibility..."
        if ! docker exec "$CONTAINER_NAME" ps aux >/dev/null 2>&1; then
          echo "‚ùå Cannot execute commands in container"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          exit 1
        fi
        
        HEALTH_RESPONSE=$(curl -f -s http://localhost:${{ env.PORT }}/health)
        if [ $? -eq 0 ]; then
          echo "‚úÖ Health check passed: $HEALTH_RESPONSE"
        else
          echo "‚ùå Health check failed"
          echo "üîç Container logs (last 20 lines):"
          docker logs --tail 20 "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Testing with verbose curl:"
          curl -v http://localhost:${{ env.PORT }}/health || echo "Verbose curl failed"
          exit 1
        fi
        
        # Test metrics endpoint
        echo "üìä Testing metrics endpoint..."
        if curl -f -s http://localhost:${{ env.PORT }}/metrics >/dev/null 2>&1; then
          echo "‚úÖ Metrics endpoint accessible"
          # Show sample metrics
          echo "üìà Sample metrics:"
          curl -s http://localhost:${{ env.PORT }}/metrics | head -10
        else
          echo "‚ö†Ô∏è  Metrics endpoint not accessible"
          echo "üîç Testing with verbose curl:"
          curl -v http://localhost:${{ env.PORT }}/metrics || echo "Verbose curl failed"
        fi
        
        # Test root endpoint
        echo "üåê Testing root endpoint..."
        if curl -f -s http://localhost:${{ env.PORT }}/ >/dev/null 2>&1; then
          echo "‚úÖ Root endpoint accessible"
          # Show response content
          echo "üìÑ Root endpoint response:"
          curl -s http://localhost:${{ env.PORT }}/ | head -5
        else
          echo "‚ö†Ô∏è  Root endpoint not accessible"
          echo "üîç Testing with verbose curl:"
          curl -v http://localhost:${{ env.PORT }}/ || echo "Verbose curl failed"
        fi
        
        # Test HTTP methods
        echo "üîç Testing HTTP methods..."
        for method in GET HEAD OPTIONS; do
          if curl -f -s -X $method http://localhost:${{ env.PORT }}/ >/dev/null 2>&1; then
            echo "‚úÖ $method method works"
          else
            echo "‚ö†Ô∏è  $method method failed"
          fi
        done
        
        # Test data ingestion (if write endpoint exists)
        echo "üìù Testing data ingestion..."
        TIMESTAMP=$(date +%s)000
        WRITE_RESPONSE=$(curl -f -s -X POST \
          -H "Content-Type: application/json" \
          -d "{\"measurement\":\"test\",\"tags\":{\"host\":\"localhost\"},\"fields\":{\"value\":42.5},\"timestamp\":$TIMESTAMP}" \
          http://localhost:${{ env.PORT }}/write 2>/dev/null || echo "Write endpoint not available")
        
        if [ "$WRITE_RESPONSE" != "Write endpoint not available" ]; then
          echo "‚úÖ Data ingestion test passed: $WRITE_RESPONSE"
        else
          echo "‚ÑπÔ∏è  Write endpoint not available (this is normal for some configurations)"
        fi
        
        # Show final container status before cleanup
        echo "üìã Final container status before cleanup:"
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep "$CONTAINER_NAME" || echo "Container not found in ps output"
        
        # Show container resource usage
        echo "üìä Container resource usage:"
        docker stats --no-stream "$CONTAINER_NAME" || echo "Could not get container stats"
        
        # Cleanup
        echo "üßπ Cleaning up test container..."
        docker stop "$CONTAINER_NAME" || echo "Could not stop container"
        docker rm "$CONTAINER_NAME" || echo "Could not remove container"
        
        echo "üéâ Docker image testing completed successfully!"
        echo "‚úÖ All endpoints tested successfully"
        echo "üìä Container was healthy and responsive"
        echo "üîå Port ${{ env.PORT }} was accessible"

    - name: Push Docker image
      if: github.event_name != 'pull_request'
      run: |
        echo "üì§ Pushing Docker image to registry..."
        
        # Tag for registry
        docker tag ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }} \
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
        docker tag ${{ env.IMAGE_NAME }}:latest \
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        
        # Push images
        docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
        docker push ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest
        
        echo "‚úÖ Images pushed successfully"

    - name: Test pushed image
      if: github.event_name != 'pull_request'
      run: |
        echo "üß™ Testing pushed image from registry..."
        
        # Pull the pushed image
        docker pull ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
        
        # Quick verification
        CONTAINER_NAME="test-pushed-$(date +%s)"
        CONTAINER_ID=$(docker run -d \
          --name "$CONTAINER_NAME" \
          -p 8081:${{ env.PORT }} \
          ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }})
        
        echo "Container ID: $CONTAINER_ID"
        
        # Wait and test
        echo "‚è≥ Waiting for pushed image container to start..."
        sleep 5
        
        # Verify container is running
        if ! docker ps --format "table {{.Names}}" | grep -q "$CONTAINER_NAME"; then
          echo "‚ùå Pushed image container failed to start"
          echo "üîç Container logs:"
          docker logs "$CONTAINER_NAME" || echo "Could not retrieve logs"
          exit 1
        fi
        
        # Test health endpoint
        echo "üè• Testing pushed image health endpoint..."
        if curl -f -s http://localhost:8081/health >/dev/null 2>&1; then
          echo "‚úÖ Pushed image test passed"
        else
          echo "‚ùå Pushed image test failed"
          echo "üîç Container logs (last 20 lines):"
          docker logs --tail 20 "$CONTAINER_NAME" || echo "Could not retrieve logs"
          echo "üîç Testing with verbose curl:"
          curl -v http://localhost:8081/health || echo "Verbose curl failed"
          exit 1
        fi
        
        # Cleanup
        docker stop "$CONTAINER_NAME" || echo "Could not stop container"
        docker rm "$CONTAINER_NAME" || echo "Could not remove container"

    - name: Final summary
      if: always()
      run: |
        echo "üèÅ Build and test process completed"
        echo "=================================="
        echo "Workflow: ${{ github.workflow }}"
        echo "Run ID: ${{ github.run_id }}"
        echo "Triggered by: ${{ github.actor }}"
        echo "Repository: ${{ github.repository }}"
        echo "Ref: ${{ github.ref }}"
        echo "SHA: ${{ github.sha }}"
        echo "Timestamp: $(date -u)"
        echo ""
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ All steps completed successfully"
          echo "üéâ Docker image built, tested, and verified!"
          echo "üì¶ Local image: ${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo "üì§ Registry image: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}"
          fi
        else
          echo "‚ùå Some steps failed"
          echo "üîç Check the logs above for detailed error information"
        fi
        
        echo "=================================="


      